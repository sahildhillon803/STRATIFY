from datetime import datetime, timedelta
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordRequestForm
import httpx

from app.core import security
from app.core.config import settings
from app.models.user import User
from app.schemas.user import (
    UserCreate, 
    UserResponse,
    PasswordResetRequest,
    PasswordResetConfirm,
    PasswordResetResponse,
    PasswordChangeRequest,
    GoogleAuthRequest,
    UserResponseWithPicture,
)
from app.schemas.token import Token
from app.api.v1.deps import get_current_user

router = APIRouter()

# Google OAuth token verification URL
GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo"


import logging

logger = logging.getLogger(__name__)

@router.post("/register", response_model=UserResponse)
async def register_user(user_in: UserCreate):
    """
    Register a new user account.
    """
    logger.info(f"Registration attempt for: {user_in.email}")
    
    # 1. Check if user exists
    logger.info("Checking if user exists...")
    existing_user = await User.find_one(User.email == user_in.email)
    if existing_user:
        logger.info("User already exists")
        raise HTTPException(
            status_code=400,
            detail="The user with this email already exists in the system.",
        )

    logger.info("Creating new user...")
    # 2. Create user
    user = User(
        email=user_in.email,
        hashed_password=security.get_password_hash(user_in.password),
        full_name=user_in.full_name,
    )
    await user.create()
    logger.info(f"User created with id: {user.id}")

    # 3. Return (id is automatically generated by MongoDB)
    return UserResponse(
        id=str(user.id),
        email=user.email,
        full_name=user.full_name,
        is_active=user.is_active
    )


@router.post("/login", response_model=Token)
async def login_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    # 1. Authenticate
    user = await User.find_one(User.email == form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect email or password")

    if not user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")

    # 2. Update last login
    user.last_login = datetime.utcnow()
    await user.save()

    # 3. Create Token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    return {
        "access_token": security.create_access_token(
            subject=user.id, expires_delta=access_token_expires
        ),
        "token_type": "bearer",
    }


@router.post("/forgot-password", response_model=PasswordResetResponse)
async def forgot_password(request: PasswordResetRequest):
    """
    Request a password reset link.
    
    In production, this sends an email with a reset link.
    In development mode, it returns the token directly for testing.
    """
    # Find user by email
    user = await User.find_one(User.email == request.email)
    
    # Always return success to prevent email enumeration attacks
    # But only generate token if user exists
    if user:
        reset_token = security.create_password_reset_token(request.email)
        
        # In production, send email here:
        # await send_password_reset_email(request.email, reset_token)
        
        # For development/demo, return token directly
        if settings.DEBUG:
            return PasswordResetResponse(
                message="Password reset instructions have been sent to your email.",
                reset_token=reset_token  # Only in dev mode!
            )
    
    # Same response whether user exists or not (security)
    return PasswordResetResponse(
        message="If an account with that email exists, password reset instructions have been sent."
    )


@router.post("/reset-password", response_model=dict)
async def reset_password(request: PasswordResetConfirm):
    """
    Reset password using a valid reset token.
    """
    # Verify token
    email = security.verify_password_reset_token(request.token)
    if not email:
        raise HTTPException(
            status_code=400,
            detail="Invalid or expired password reset token"
        )
    
    # Find user
    user = await User.find_one(User.email == email)
    if not user:
        raise HTTPException(
            status_code=404,
            detail="User not found"
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=400,
            detail="Inactive user"
        )
    
    # Update password
    user.hashed_password = security.get_password_hash(request.new_password)
    await user.save()
    
    return {"message": "Password has been reset successfully. You can now login with your new password."}


@router.post("/change-password", response_model=dict)
async def change_password(
    request: PasswordChangeRequest,
    current_user: User = Depends(get_current_user)
):
    """
    Change password for the currently logged-in user.
    Requires authentication and current password verification.
    """
    # Verify current password
    if not security.verify_password(request.current_password, current_user.hashed_password):
        raise HTTPException(
            status_code=400,
            detail="Incorrect current password"
        )
    
    # Update to new password
    current_user.hashed_password = security.get_password_hash(request.new_password)
    await current_user.save()
    
    return {"message": "Password changed successfully"}


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """
    Get current logged-in user information.
    """
    return UserResponse(
        id=str(current_user.id),
        email=current_user.email,
        full_name=current_user.full_name,
        is_active=current_user.is_active
    )


@router.post("/google", response_model=dict)
async def google_oauth_login(request: GoogleAuthRequest):
    """
    Authenticate with Google OAuth.
    
    Receives a Google ID token from the frontend, verifies it with Google,
    and either logs in an existing user or creates a new account.
    """
    # Verify the Google token
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                GOOGLE_TOKEN_INFO_URL,
                params={"id_token": request.credential}
            )
            
            if response.status_code != 200:
                raise HTTPException(
                    status_code=400,
                    detail="Invalid Google token"
                )
            
            google_data = response.json()
    except httpx.RequestError:
        raise HTTPException(
            status_code=503,
            detail="Unable to verify Google token. Please try again."
        )
    
    # Verify the token is for our app (if GOOGLE_CLIENT_ID is configured)
    if settings.GOOGLE_CLIENT_ID:
        if google_data.get("aud") != settings.GOOGLE_CLIENT_ID:
            raise HTTPException(
                status_code=400,
                detail="Invalid token audience"
            )
    
    # Extract user info from Google token
    email = google_data.get("email")
    google_id = google_data.get("sub")
    full_name = google_data.get("name")
    profile_picture = google_data.get("picture")
    email_verified = google_data.get("email_verified", "false") == "true"
    
    if not email or not google_id:
        raise HTTPException(
            status_code=400,
            detail="Invalid Google token data"
        )
    
    if not email_verified:
        raise HTTPException(
            status_code=400,
            detail="Google email not verified"
        )
    
    # Check if user exists by Google ID or email
    user = await User.find_one(
        {"$or": [
            {"oauth_provider": "google", "oauth_id": google_id},
            {"email": email}
        ]}
    )
    
    is_new_user = False
    
    if user:
        # Existing user - update OAuth info if needed
        if not user.oauth_provider:
            # User registered with email/password, now linking Google
            user.oauth_provider = "google"
            user.oauth_id = google_id
        if profile_picture and not user.profile_picture:
            user.profile_picture = profile_picture
        if full_name and not user.full_name:
            user.full_name = full_name
        user.last_login = datetime.utcnow()
        await user.save()
    else:
        # New user - create account
        user = User(
            email=email,
            full_name=full_name,
            oauth_provider="google",
            oauth_id=google_id,
            profile_picture=profile_picture,
            hashed_password=None,  # No password for OAuth users
        )
        await user.create()
        is_new_user = True
    
    if not user.is_active:
        raise HTTPException(status_code=400, detail="User account is inactive")
    
    # Create access token
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        subject=user.id, expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "is_new_user": is_new_user,
        "user": {
            "id": str(user.id),
            "email": user.email,
            "full_name": user.full_name,
            "profile_picture": user.profile_picture,
            "oauth_provider": user.oauth_provider,
        }
    }


@router.get("/google/client-id")
async def get_google_client_id():
    """
    Returns the Google Client ID for frontend configuration.
    This endpoint is public so the frontend can initialize Google Sign-In.
    """
    if not settings.GOOGLE_CLIENT_ID:
        raise HTTPException(
            status_code=404,
            detail="Google OAuth not configured"
        )
    return {"client_id": settings.GOOGLE_CLIENT_ID}
